<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Mi Universo para Ti</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000; 
      font-family: 'Arial', sans-serif;
    }
    canvas { 
      display: block; 
      width: 100%; 
      height: 100%;
    }
    #mensaje {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      font-size: 28px;
      font-weight: bold;
      color: #ff9ee0;
      text-shadow: 0 0 10px #ff65c6, 0 0 20px #ff65c6;
      animation: brillo 3s infinite alternate;
      z-index: 100;
      pointer-events: none;
    }
    @keyframes brillo {
      from { opacity: 0.7; }
      to { opacity: 1; }
    }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      z-index: 1000;
    }
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      pointer-events: none;
    }
    .distance-indicator {
      position: absolute;
      top: 70px;
      width: 100%;
      text-align: center;
      color: white;
      font-size: 14px;
      pointer-events: none;
      opacity: 0.7;
    }
    .romantic-message {
      position: absolute;
      color: #ff9ee0;
      font-size: 16px;
      text-shadow: 0 0 5px #ff65c6;
      opacity: 0;
      transition: opacity 2s;
      pointer-events: none;
      text-align: center;
      width: 200px;
    }
    .planet-message {
      position: absolute;
      color: white;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 10px;
      border-radius: 10px;
      opacity: 0;
      transition: opacity 1s;
      pointer-events: none;
      text-align: center;
      width: 140px;
      transform: translateX(-50%);
    }
    .love-particle {
      position: absolute;
      font-size: 16px;
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="mensaje">En este universo infinito... mi lugar favorito eres t√∫ üíñ</div>
  <div class="distance-indicator" id="distanceIndicator">Distancia: Media</div>
  <div id="loading">Cargando el universo...</div>
  <div id="instructions">Usa la rueda del mouse para acercar/alejar ‚Ä¢ Haz clic y arrastra para rotar</div>

  <!-- Importmap para usar m√≥dulos -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Ocultar loading cuando todo est√© listo
    window.addEventListener('load', () => {
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        iniciarUniverso();
      }, 3000);
			
			
    });
		
		// üå∏ Flores y ramos amarillos, morados y azules
function createFlowers(scene) {
	
  const bouquetGroup = new THREE.Group();

  const flowerColors = [0xffd700, 0x9370db, 0x1e90ff]; // amarillo, morado, azul
  const stemMaterial = new THREE.MeshStandardMaterial({
    color: 0x228B22,
    roughness: 0.7,
    metalness: 0.1
  });

  // ----- funci√≥n que crea UNA sola flor -----
  function makeFlower(color) {
    const flower = new THREE.Group();

    // tallo
    const stem = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.2, 4, 8),
      stemMaterial
    );
    stem.position.y = 2;
    flower.add(stem);

    // centro
    const center = new THREE.Mesh(
      new THREE.SphereGeometry(0.4, 16, 16),
      new THREE.MeshStandardMaterial({ color: 0x444000, roughness: 0.5 })
    );
    center.position.y = 4;
    flower.add(center);

    // p√©talos
    const petalGeom = new THREE.SphereGeometry(0.7, 16, 16);
    const petalMat = new THREE.MeshStandardMaterial({
      color,
      roughness: 0.4,
      metalness: 0.2
    });

    const petals = 6;
    for (let i = 0; i < petals; i++) {
      const angle = (i / petals) * Math.PI * 2;
      const radius = 1.0;
      const petal = new THREE.Mesh(petalGeom, petalMat);
      petal.position.set(Math.cos(angle) * radius, 4, Math.sin(angle) * radius);
      petal.scale.set(0.5, 0.2, 0.5);
      flower.add(petal);
    }

    return flower;
  }

  // ----- ahora creamos RAMOS -----
  for (let r = 0; r < 5; r++) { // n√∫mero de ramos
    const ramo = new THREE.Group();
    ramo.position.set(
      (Math.random() - 2) * 40,
      0,
      (Math.random() - 2) * 40
    );

    // cada ramo tiene 5 a 8 flores juntas
    const count = 5 + Math.floor(Math.random() * 4);
    for (let i = 0; i < count; i++) {
      const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];
      const flower = makeFlower(color);
      // colocaci√≥n compacta dentro del ramo
      flower.position.set(
        (Math.random() - 0.5) * 4,
        0,
        (Math.random() - 0.5) * 4
      );
      ramo.add(flower);
    }

    bouquetGroup.add(ramo);
  }

  scene.add(bouquetGroup);
  return bouquetGroup;
}
  

    function iniciarUniverso() {
			
			
    // ‚úÖ PRIMERO creamos la escena
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 3000);
    camera.position.set(0, 200, 500);

    const renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x330033);
    document.body.appendChild(renderer.domElement);

    // ‚úÖ DESPU√âS llamamos a las flores
    

    // ... (el resto de tu c√≥digo sigue igual) ...
}
			
      // Escena, c√°mara, render
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 3000);
      camera.position.set(0, 200, 500);

      const renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        powerPreference: "high-performance"
      });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x330033); // Fondo m√°s brillante con tono p√∫rpura
      document.body.appendChild(renderer.domElement);

      // Controles mejorados con l√≠mites para evitar temblores
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 50;
      controls.maxDistance = 1200;
      controls.screenSpacePanning = false;
      controls.minPolarAngle = 0;
      controls.maxPolarAngle = Math.PI;

      // Funci√≥n para limitar la c√°mara y evitar que salga de los l√≠mites
      function limitarCamara() {
        const maxDistance = 1200;
        const minDistance = 50;
        
        if (camera.position.length() > maxDistance) {
          camera.position.normalize().multiplyScalar(maxDistance);
        }
        
        if (camera.position.length() < minDistance) {
          camera.position.normalize().multiplyScalar(minDistance);
        }
        
        controls.update();
      }

      // Luces mejoradas con m√°s brillo y tonos rosas
      const ambient = new THREE.AmbientLight(0xffffff, 1.0); // Luz ambiental con tono p√∫rpura
      scene.add(ambient);
      
      const pointLight = new THREE.PointLight(0xffbbff, 3, 1000); // Luz con tono rosa
      pointLight.position.set(0, 0, 0);
      scene.add(pointLight);
      
			createFlowers(scene);
      // Luz direccional adicional para m√°s brillo
      const directionalLight = new THREE.DirectionalLight(0xffddff, 0.5);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);

      // Cargar texturas de planetas locales
      const loader = new THREE.TextureLoader();
      
      const loadTexture = (path) => {
        return loader.load(path, undefined, undefined, (error) => {
          console.error(`Error cargando textura: ${path}`, error); // ERROR CORREGIDO
        });
      };

      // Texturas de planetas locales - CORREGIDAS LAS RUTAS
      const textures = {
        sun: loadTexture("textures/8k_sun.jpg"),
        earth: loadTexture("textures/8k_earth_nightmap.jpg"),
        jupiter: loadTexture("textures/8k_jupiter.jpg"),
        mars: loadTexture("textures/8k_mars.jpg"),
        uranus: loadTexture("textures/2k_uranus.jpg"),
        saturn: loadTexture("textures/8k_saturn.jpg"),
        ring: loadTexture("textures/8k_saturn_ring_alpha.png")
      };

      // Esfera de l√≠mite del universo con m√°s brillo
      const createUniverseBoundary = () => {
        const boundaryGeometry = new THREE.SphereGeometry(1400, 64, 64);
        const boundaryMaterial = new THREE.MeshBasicMaterial({
          color: 0x220033, // Color m√°s brillante
          side: THREE.BackSide,
          transparent: true,
          opacity: 0.8 // M√°s brillo
        });
        
        const boundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
        scene.add(boundary);
        
        return boundary;
      };

      const universeBoundary = createUniverseBoundary();

      // Fondo de estrellas mejorado con m√°s estrellas y brillo
      const createStarField = () => {
        const starsGeometry = new THREE.BufferGeometry();
        const starCount = 18000; // M√°s estrellas
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);
        
        const color = new THREE.Color();
        
        for (let i = 0; i < starCount; i++) {
          const i3 = i * 3;
          const radius = 800 + Math.random() * 600;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          
          starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          starPositions[i3 + 2] = radius * Math.cos(phi);
          
          // Colores m√°s brillantes con tonos rosas y p√∫rpuras
          const randomValue = Math.random();
          if (randomValue < 0.5) {
            color.setRGB(0.9, 0.9, 1.0); // Azul claro brillante
          } else if (randomValue < 0.7) {
            color.setRGB(1.0, 0.8, 0.9); // Rosa
          } else if (randomValue < 0.85) {
            color.setRGB(0.9, 0.7, 1.0); // P√∫rpura
          } else {
            color.setRGB(1.0, 1.0, 0.8); // Amarillo claro
          }
          
          starColors[i3] = color.r;
          starColors[i3 + 1] = color.g;
          starColors[i3 + 2] = color.b;
          
          starSizes[i] = Math.random() * 2.0 + 0.5; // Estrellas m√°s grandes
        }
        
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        starsGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
        
        const starsMaterial = new THREE.PointsMaterial({
          size: 2.5, // Aumentado tama√±o
          sizeAttenuation: true,
          vertexColors: true,
          transparent: true,
          opacity: 1.0 // M√°s brillo
        });
        
        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);
        
        return starField;
      };

      const starField = createStarField();

      // Constelaci√≥n en forma de coraz√≥n con estrellas parpadeantes - m√°s femenina
      const createHeartConstellation = () => {
        const heartGroup = new THREE.Group();
        heartGroup.position.set(-300, 100, -200);
        
        // Crear puntos para formar un coraz√≥n
        const heartPoints = [];
        for (let t = 0; t < 2 * Math.PI; t += 0.08) { // M√°s puntos para un coraz√≥n m√°s definido
          const x = 16 * Math.pow(Math.sin(t), 3);
          const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
          heartPoints.push(new THREE.Vector3(x * 2, y * 2, 0));
        }
        
        // Crear estrellas en los puntos del coraz√≥n
        const starsGeometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];
        const alphas = [];
        
        heartPoints.forEach(point => {
          positions.push(point.x, point.y, point.z);
          
          // Colores rosas y p√∫rpuras para un toque femenino
          colors.push(1.0, 0.6, 0.9); // Rosa
          colors.push(1.0, 0.6, 0.9); // Rosa
          colors.push(1.0, 0.6, 0.9); // Rosa
          
          sizes.push(5 + Math.random() * 3); // M√°s grandes
          alphas.push(Math.random());
        });
        
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        starsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        starsGeometry.setAttribute('alpha', new THREE.Float32BufferAttribute(alphas, 1));
        
        const heartMaterial = new THREE.PointsMaterial({
          size: 6, // M√°s grandes
          sizeAttenuation: true,
          vertexColors: true,
          transparent: true,
					alphaTest: 0.1
        });
        
        const heartStars = new THREE.Points(starsGeometry, heartMaterial);
        heartGroup.add(heartStars);
        
        // L√≠neas conectando las estrellas - en rosa
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setFromPoints(heartPoints);
        
        const lineMaterial = new THREE.LineBasicMaterial({
          color: 0xff66cc,
          transparent: true,
          opacity: 0.6 // M√°s brillo
        });
        
        const heartLine = new THREE.Line(lineGeometry, lineMaterial);
        heartGroup.add(heartLine);
        
        // A√±adir part√≠culas brillantes alrededor del coraz√≥n
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = [];
        const particleColors = [];
        
        for (let i = 0; i < 200; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = 25 + Math.random() * 15;
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;
          const z = (Math.random() - 0.5) * 10;
          
          particlePositions.push(x, y, z);
          
          // Part√≠culas en tonos rosas y p√∫rpuras
          if (Math.random() > 0.5) {
            particleColors.push(1.0, 0.7, 0.9); // Rosa
          } else {
            particleColors.push(0.8, 0.6, 1.0); // P√∫rpura
          }
        }
        
        particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
        particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
          size: 3,
          sizeAttenuation: true,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
					alphaTest: 0.1 
        });
        
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        heartGroup.add(particles);
        
        scene.add(heartGroup);
        
        return { group: heartGroup, stars: heartStars, points: heartPoints, alphas: alphas, particles: particles };
      };

      const heartConstellation = createHeartConstellation();

      // Sol con efecto de brillo aumentado y tonos m√°s c√°lidos
      const createSun = () => {
        const sunGeometry = new THREE.SphereGeometry(50, 64, 64);
        const sunMaterial = new THREE.MeshBasicMaterial({
          map: textures.sun,
          emissive: 0xffcc00, // Tonos m√°s dorados
          emissiveIntensity: 1.0  // M√°s brillo
        });
        
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        
        const coronaGeometry = new THREE.SphereGeometry(60, 32, 32); // M√°s grande
        const coronaMaterial = new THREE.MeshBasicMaterial({
          color: 0xffaa88, // Color m√°s c√°lido
          transparent: true,
          opacity: 0.25,  // M√°s brillo
          side: THREE.BackSide
        });
        
        const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
        sun.add(corona);
        
        // A√±adir destellos de luz
        const flareGeometry = new THREE.SphereGeometry(5, 16, 16);
        const flareMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.7
        });
        
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const distance = 60 + Math.random() * 20;
          const flare = new THREE.Mesh(flareGeometry, flareMaterial);
          flare.position.set(
            Math.cos(angle) * distance,
            Math.sin(angle) * distance,
            (Math.random() - 0.5) * 20
          );
          sun.add(flare);
        }
        
        return sun;
      };

      const sun = createSun();
			
			

      // Funci√≥n para crear planetas con texturas y m√°s brillo
      function crearPlaneta(texture, size, distance, speed, tilt = 0, colorOverride = null) {
        const material = texture ?
          new THREE.MeshStandardMaterial({ 
            map: texture,
            roughness: 0.4,  // Reducido para m√°s brillo
            metalness: 0.3,  // Aumentado para m√°s reflectividad
            emissive: colorOverride ? new THREE.Color(colorOverride).multiplyScalar(0.5) : new THREE.Color(0x555555),
            emissiveIntensity: 0.1 // M√°s brillo
          }) :
          new THREE.MeshStandardMaterial({ 
            color: colorOverride,
            roughness: 0.6, // M√°s brillo
            metalness: 0.2, // M√°s reflectivo
            emissive: new THREE.Color(colorOverride).multiplyScalar(0.7),
            emissiveIntensity: 0.4// M√°s brillo
          });
          
        const planet = new THREE.Mesh(new THREE.SphereGeometry(size, 32, 32), material);
        const pivot = new THREE.Object3D();
        pivot.add(planet);

        planet.rotation.z = tilt;
        planet.position.x = distance;

        scene.add(pivot);
        return { planet, pivot, speed: speed * 0.5 };
      }

      // Planetas del sistema solar con texturas - colores m√°s vibrantes
      const planetas = [
        crearPlaneta(null, 8, 70, 0.015, 0.05, 0xaaaaaa), // Mercurio - m√°s brillo
        crearPlaneta(null, 10, 100, 0.012, 0.03, 0xffddbb), // Venus - m√°s brillo, tono dorado
        crearPlaneta(textures.earth, 12, 140, 0.01, 0.41, 0x333333), // Tierra
        crearPlaneta(textures.mars, 9, 190, 0.008, 0.44, 0xff8888), // Marte - rojo m√°s vibrante
        crearPlaneta(textures.jupiter, 20, 280, 0.004, 0.05), // J√∫piter
        crearPlaneta(textures.saturn, 18, 380, 0.003, 0.47), // Saturno
        crearPlaneta(textures.uranus, 14, 460, 0.002, 1.7, 0xaaccff), // Urano - azul m√°s brillante
        crearPlaneta(null, 13, 520, 0.001, 0.5, 0x5588ff) // Neptuno - azul m√°s vibrante
      ];

      // Planetas rom√°nticos adicionales (tonos pastel femeninos)
      const romanticPlanets = [];
      const romanticMessages = [
        "Eres la estrella de mi cielo üí´",
        "Mi coraz√≥n late por ti üíó",
        "Juntos somos constelaci√≥n üíû",
        "Eres mi destino c√≥smico üå†",
        "Tu amor ilumina mi universo ‚ú®",
        "Eres mi galaxia favorita üåå",
        "Nuestro amor es atemporal ‚è≥",
        "Eres mi sol y mis estrellas ‚òÄÔ∏è",
        "Contigo el universo tiene sentido üíñ",
        "Eres mi fen√≥meno celestial üåô",
        "Mi amor por ti es infinito ‚ôæÔ∏è",
        "Eres mi para√≠so estelar ü™ê"
      ];

      // Crear planetas rom√°nticos con tonos pastel
      for (let i = 0; i < 8; i++) { // M√°s planetas rom√°nticos
        // Tonos pastel femeninos: rosa, lila, menta, lavanda, etc.
        const colors = [0xffb6c1, 0xdda0dd, 0xb0e0e6, 0xe6e6fa, 0xffd700, 0x98fb98, 0xadd8e6, 0xf0e68c];
        const color = colors[i % colors.length];
        const size = 5 + Math.random() * 4;
        const distance = 600 + Math.random() * 300;
        const speed = 0.001 + Math.random() * 0.002;
        
        const planetData = crearPlaneta(null, size, distance, speed, Math.random() * 0.5, color);
        
        // Posicionar en diferentes √°ngulos
        planetData.pivot.rotation.y = Math.random() * Math.PI * 2;
        
        // A√±adir brillo a los planetas
        const glowGeometry = new THREE.SphereGeometry(size * 1.5, 32, 32); // M√°s grande
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.4,  // M√°s brillo
          side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        planetData.planet.add(glow);
        
        // A√±adir anillos a algunos planetas
        if (Math.random() > 0.7) {
          const ringGeometry = new THREE.RingGeometry(size * 1.1, size * 1.4, 32);
          const ringMaterial = new THREE.MeshBasicMaterial({
            color: color,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6
          });
          const ring = new THREE.Mesh(ringGeometry, ringMaterial);
          ring.rotation.x = Math.PI / 2;
          planetData.planet.add(ring);
        }
        
        romanticPlanets.push({
          ...planetData,
          message: romanticMessages[i],
          messageElement: null
        });
      }

      // Crear elementos DOM para los mensajes de los planetas
      romanticPlanets.forEach((planet, index) => {
        const messageElement = document.createElement('div');
        messageElement.className = 'planet-message';
        messageElement.textContent = planet.message;
        messageElement.style.fontSize = '14px';
        messageElement.style.fontStyle = 'italic';
        document.body.appendChild(messageElement);
        romanticPlanets[index].messageElement = messageElement;
      });

      // Anillo de Saturno mejorado
      const ringGeometry = new THREE.RingGeometry(22, 30, 64);
      const ringMaterial = new THREE.MeshBasicMaterial({
        map: textures.ring,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.9  // M√°s brillo
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2;
      planetas[5].planet.add(ring);

      // Qu√°sar mejorado con tonos rosas y p√∫rpuras
      const createQuasar = () => {
        const quasarGroup = new THREE.Group();
        quasarGroup.position.set(600, 200, -300);
        
        // N√∫cleo del qu√°sar
        const quasarGeometry = new THREE.SphereGeometry(20, 32, 32);
        const quasarMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          emissive: 0xffccff, // Tono rosa
          emissiveIntensity: 1.2  // M√°s brillo
        });
        
        const quasar = new THREE.Mesh(quasarGeometry, quasarMaterial);
        quasarGroup.add(quasar);
        
        // Disco de acreci√≥n con tonos p√∫rpuras
        const accretionGeometry = new THREE.RingGeometry(22, 45, 64);
        const accretionMaterial = new THREE.MeshBasicMaterial({
          color: 0xcc88ff, // P√∫rpura
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.9  // M√°s brillo
        });
        
        const accretionDisk = new THREE.Mesh(accretionGeometry, accretionMaterial);
        accretionDisk.rotation.x = Math.PI / 2;
        quasarGroup.add(accretionDisk);
        
        // Jets de part√≠culas con tonos azules
        const createJet = (direction) => {
          const jetGroup = new THREE.Group();
          
          for (let i = 0; i < 25; i++) {
            const length = 5 + Math.random() * 10;
            const jetGeometry = new THREE.ConeGeometry(0.5, length, 8);
            jetGeometry.rotateX(Math.PI / 2);
            
            const jetMaterial = new THREE.MeshBasicMaterial({
              color: 0x88ccff, // Azul claro
              transparent: true,
              opacity: 0.8  // M√°s brillo
            });
            
            const jetPiece = new THREE.Mesh(jetGeometry, jetMaterial);
            
            const pos = i * 8;
            jetPiece.position.set(
              direction === 'left' ? -pos : pos,
              (Math.random() - 0.5) * 3,
              (Math.random() - 0.5) * 3
            );
            
            jetPiece.userData = {
              speed: 0.5 + Math.random() * 0.5
            };
            
            jetGroup.add(jetPiece);
          }
          
          quasarGroup.add(jetGroup);
          return jetGroup;
        };
        
        const leftJet = createJet('left');
        const rightJet = createJet('right');
        
        // Part√≠culas de energ√≠a con tonos pastel
        for (let i = 0; i < 40; i++) {
          const particleSize = 1 + Math.random() * 3;
          const particleGeometry = new THREE.SphereGeometry(particleSize, 8, 8);
          const particleMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color(Math.random() * 0.5 + 0.5, Math.random() * 0.5 + 0.5, 1.0),
            transparent: true,
            opacity: 0.7  // M√°s brillo
          });
          
          const particle = new THREE.Mesh(particleGeometry, particleMaterial);
          
          const distance = 25 + Math.random() * 40;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          
          particle.position.set(
            distance * Math.sin(phi) * Math.cos(theta),
            distance * Math.sin(phi) * Math.sin(theta),
            distance * Math.cos(phi)
          );
          
          particle.userData = {
            speed: 0.1 + Math.random() * 0.2
          };
          
          quasarGroup.add(particle);
        }
        
        scene.add(quasarGroup);
        return { group: quasarGroup, leftJet, rightJet };
      };

      const quasar = createQuasar();

      // Cintur√≥n de asteroides con m√°s brillo
      const createAsteroidBelt = () => {
        const asteroidBelt = new THREE.Group();
        const asteroidCount = 400; // M√°s asteroides
        
        for (let i = 0; i < asteroidCount; i++) {
          const size = 0.5 + Math.random() * 3;
          const asteroidGeometry = new THREE.SphereGeometry(size, 6, 6);
          
          const positionAttribute = asteroidGeometry.getAttribute('position');
          for (let j = 0; j < positionAttribute.count; j++) {
            positionAttribute.setXYZ(
              j,
              positionAttribute.getX(j) * (0.8 + Math.random() * 0.4),
              positionAttribute.getY(j) * (0.8 + Math.random() * 0.4),
              positionAttribute.getZ(j) * (0.8 + Math.random() * 0.4)
            );
          }
          positionAttribute.needsUpdate = true;
          
          const asteroidMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(0.7 + Math.random() * 0.3, 0.6 + Math.random() * 0.3, 0.5 + Math.random() * 0.3), // M√°s brillo
            roughness: 0.7, // M√°s brillo
            metalness: 0.3  // M√°s reflectivo
          });
          
          const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
          
          const radius = 650 + Math.random() * 100;
          const angle = Math.random() * Math.PI * 2;
          const height = (Math.random() - 0.5) * 30;
          
          asteroid.position.set(
            Math.cos(angle) * radius,
            height,
            Math.sin(angle) * radius
          );
          
          asteroid.userData = {
            rotationSpeed: (Math.random() - 0.5) * 0.01,
            orbitSpeed: (0.002 + Math.random() * 0.002) * (Math.random() > 0.5 ? 1 : -1)
          };
          
          asteroidBelt.add(asteroid);
        }
        
        scene.add(asteroidBelt);
        return asteroidBelt;
      };

      const asteroidBelt = createAsteroidBelt();

      // Nebulosas en tonos rosa y violeta - m√°s brillantes y femeninas
      const createNebulas = () => {
        const nebulas = [];
        const nebulaCount = 6; // M√°s nebulosas
        
        for (let i = 0; i < nebulaCount; i++) {
          const size = 80 + Math.random() * 80;
          const nebulaGeometry = new THREE.SphereGeometry(size, 32, 32);
          
          // Crear material con color aleatorio entre rosa y violeta
          const color = new THREE.Color();
          if (Math.random() > 0.5) {
            color.setRGB(0.9 + Math.random() * 0.1, 0.5 + Math.random() * 0.2, 0.7 + Math.random() * 0.3); // Rosas m√°s brillantes
          } else {
            color.setRGB(0.8 + Math.random() * 0.2, 0.4 + Math.random() * 0.2, 0.9 + Math.random() * 0.1); // Violetas m√°s brillantes
          }
          
          const nebulaMaterial = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.25 + Math.random() * 0.1,  // M√°s brillo
            side: THREE.DoubleSide,
            wireframe: false
          });
          
          const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
          
          // Posici√≥n aleatoria
          nebula.position.set(
            Math.random() * 2000 - 1000,
            Math.random() * 1000 - 500,
            Math.random() * 2000 - 1000
          );
          
          nebula.userData = {
            rotationSpeed: (Math.random() - 0.5) * 0.001
          };
          
          scene.add(nebula);
          nebulas.push(nebula);
        }
        
        return nebulas;
      };

      const nebulas = createNebulas();

      // Galaxias espirales en el fondo - m√°s brillantes
      const createBackgroundGalaxies = () => {
        const galaxies = [];
        const galaxyCount = 5; // M√°s galaxias
        
        for (let i = 0; i < galaxyCount; i++) {
          const size = 60 + Math.random() * 50;
          const galaxyGeometry = new THREE.RingGeometry(size * 0.7, size, 64);
          
          const galaxyMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.35 + Math.random() * 0.1  // M√°s brillo
          });
          
          const galaxy = new THREE.Mesh(galaxyGeometry, galaxyMaterial);
          
          // Posicionar en el fondo
          galaxy.position.set(
            Math.random() * 2500 - 1250,
            Math.random() * 1200 - 600,
            -1200 - Math.random() * 300
          );
          
          // Rotaci√≥n aleatoria
          galaxy.rotation.x = Math.random() * Math.PI;
          galaxy.rotation.y = Math.random() * Math.PI;
          galaxy.rotation.z = Math.random() * Math.PI;
          
          galaxy.userData = {
            rotationSpeed: (Math.random() - 0.5) * 0.0005
          };
          
          scene.add(galaxy);
          galaxies.push(galaxy);
        }
        
        return galaxies;
      };

      const backgroundGalaxies = createBackgroundGalaxies();

      // Part√≠culas m√°gicas alrededor de planetas y constelaci√≥n - m√°s brillo
      const createMagicParticles = () => {
        const particlesGeometry = new THREE.BufferGeometry();
        const particleCount = 1000; // M√°s part√≠culas
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const alphas = new Float32Array(particleCount);
        
        const color = new THREE.Color();
        
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          
          // Agrupar part√≠culas alrededor de planetas y constelaci√≥n
          let center;
          if (i % 3 === 0 && romanticPlanets.length > 0) {
            // Alrededor de planetas rom√°nticos
            const planet = romanticPlanets[Math.floor(Math.random() * romanticPlanets.length)];
            center = planet.planet.position.clone();
            center.applyMatrix4(planet.planet.matrixWorld);
            color.set(planet.planet.material.color);
          } else if (i % 3 === 1) {
            // Alrededor del coraz√≥n
            center = heartConstellation.group.position.clone();
            color.setRGB(1, 0.7, 0.9); // Rosa m√°s brillante
          } else {
            // Aleatorias en el espacio
            center = new THREE.Vector3(
              Math.random() * 2000 - 1000,
              Math.random() * 1000 - 500,
              Math.random() * 2000 - 1000
            );
            color.setRGB(0.9, 0.9, 1); // Azul claro m√°s brillante
          }
          
          // Radio aleatorio alrededor del centro
          const radius = 15 + Math.random() * 25;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          
          positions[i3] = center.x + radius * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = center.y + radius * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = center.z + radius * Math.cos(phi);
          
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
          
          sizes[i] = 1.0 + Math.random() * 2.0; // M√°s grandes
          alphas[i] = Math.random();
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        particlesGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
        
        const particlesMaterial = new THREE.PointsMaterial({
          size: 3.0, // M√°s grandes
          sizeAttenuation: true,
          vertexColors: true,
          transparent: true
        });
        
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);
        
        return { particles, alphas };
      };

      const magicParticles = createMagicParticles();

      // Mensajes rom√°nticos flotantes - m√°s femeninos
      const romanticTexts = [
        "Cada estrella me recuerda a ti",
        "Eres mi perdona favorita",
        "Te amo mas de lo que digo",
        "Te exta√±o muchisimo. :(",
        "Eres la luz en mi oscuridad",
        "Mi coraz√≥n late al ritmo de las estrellas",
        "Eres mi galaxia, mi mundo. ",
        "El espacio entre nosotros pronto desaparecer√°",
        "Eres el sol que ilumina mi vida",
        "Dejame volver. ",
        "Eres mi destino escrito en las estrellas",
        "Cada planeta canta tu nombre",
        "Tu amor es mi fuerza, mi vida",
        "Eres la supernova que ilumin√≥ mi existencia",
        "Deja que Nuestro amor trasciende el tiempo y el espacio",
        "Eres mi fen√≥meno celestial favorito",
				"te extra√±o demasiado",
				"Eres el amor de mi vida",
				"Eres la mujer de mi vida",
				"Quiero todo contigo",
				"Por favor, perdoname."
      ];

      const createFloatingMessages = () => {
        const messages = [];
        
        romanticTexts.forEach((text, i) => {
          const messageElement = document.createElement('div');
          messageElement.className = 'romantic-message';
          messageElement.textContent = text;
          messageElement.style.color = i % 2 === 0 ? '#ff9ee0' : '#c6a8ff'; // Alternar colores
          document.body.appendChild(messageElement);
          
          messages.push({
            element: messageElement,
            position: new THREE.Vector3(
              Math.random() * 1000 - 500,
              Math.random() * 500 - 250,
              Math.random() * 1000 - 500
            ),
            visible: false,
            showTime: 5000 + Math.random() * 10000,
            hideTime: 3000 + Math.random() * 5000,
            timer: 0,
            state: 'waiting' // waiting, showing, visible, hiding
          });
        });
        
        return messages;
      };

      const floatingMessages = createFloatingMessages();

      // Part√≠culas de amor flotantes - m√°s brillo y variedad
      const createLoveParticles = () => {
        const loveParticles = [];
        const particleCount = 25; // M√°s part√≠culas
        const symbols = ['üíñ', 'ü©µ', 'üíú', 'üíó', 'üíò', 'üíù', 'üíû', '‚ú®', 'üåü', '‚≠ê', 'üåô', 'üå∫', 'üå∏', 'üå∑', 'üåπ'];
        
        for (let i = 0; i < particleCount; i++) {
          const particleElement = document.createElement('div');
          particleElement.className = 'love-particle';
          particleElement.textContent = symbols[Math.floor(Math.random() * symbols.length)];
          particleElement.style.color = `hsl(${Math.random() * 360}, 100%, 80%)`; // M√°s brillo
          particleElement.style.fontSize = `${20 + Math.random() * 10}px`; // Tama√±o variable
          document.body.appendChild(particleElement);
          
          loveParticles.push({
            element: particleElement,
            position: new THREE.Vector3(
              Math.random() * 1000 - 500,
              Math.random() * 500 - 250,
              Math.random() * 1000 - 500
            ),
            speed: 0.2 + Math.random() * 0.3,
            amplitude: 10 + Math.random() * 20,
            offset: Math.random() * Math.PI * 2
          });
        }
        
        return loveParticles;
      };

      const loveParticles = createLoveParticles();

      // Grupos de estrellas fugaces con trayectorias curvas - m√°s brillo
      const createMeteorShowers = () => {
        const meteors = [];
        const showerCount = 8; // M√°s grupos
        
        for (let s = 0; s < showerCount; s++) {
          const meteorCount = 5 + Math.floor(Math.random() * 6);
          
          for (let i = 0; i < meteorCount; i++) {
            const length = 8 + Math.random() * 15;
            const meteorGeometry = new THREE.CylinderGeometry(0.2, 1.2, length, 8);
            meteorGeometry.rotateZ(Math.PI / 2);
            
            const meteorMaterial = new THREE.MeshBasicMaterial({
              color: new THREE.Color(0.8 + Math.random() * 0.2, 0.8 + Math.random() * 0.2, 1.0), // M√°s brillo
              transparent: true,
              opacity: 0.9 // M√°s brillo
            });
            
            const meteor = new THREE.Mesh(meteorGeometry, meteorMaterial);
            
            const groupCenter = new THREE.Vector3(
              Math.random() * 1500 - 750,
              Math.random() * 800 - 400,
              Math.random() * 1500 - 750
            );
            
            const spread = 100;
            meteor.position.set(
              groupCenter.x + (Math.random() - 0.5) * spread,
              groupCenter.y + (Math.random() - 0.5) * spread,
              groupCenter.z + (Math.random() - 0.5) * spread
            );
            
            const baseDirection = new THREE.Vector3(
              Math.random() - 0.5,
              (Math.random() - 0.8) * 0.5, // M√°s hacia abajo
              Math.random() - 0.5
            ).normalize();
            
            const variation = 0.3;
            const direction = new THREE.Vector3(
              baseDirection.x + (Math.random() - 0.5) * variation,
              baseDirection.y + (Math.random() - 0.5) * variation,
              baseDirection.z + (Math.random() - 0.5) * variation
            ).normalize();
            
            // Curvatura de la trayectoria
            const curveAmount = 0.01 + Math.random() * 0.02;
            const curveAxis = new THREE.Vector3(
              Math.random() - 0.5,
              Math.random() - 0.5,
              Math.random() - 0.5
            ).normalize();
            
            meteor.userData = {
              velocity: direction.multiplyScalar(25 + Math.random() * 15),
              curveAmount: curveAmount,
              curveAxis: curveAxis,
              life: 150 + Math.random() * 100,
              group: s
            };
            
            scene.add(meteor);
            meteors.push(meteor);
          }
        }
        
        return meteors;
      };

      const meteors = createMeteorShowers();

      // Actualizar indicador de distancia
      function updateDistanceIndicator() {
        const distance = camera.position.length();
        let text = "Distancia: ";
        
        if (distance < 200) text += "Cerca";
        else if (distance < 600) text += "Media";
        else if (distance < 1000) text += "Lejos";
        else text += "Muy Lejos";
        
        document.getElementById('distanceIndicator').textContent = text;
      }

      // Actualizar posici√≥n de mensajes de planetas en la pantalla
      function updatePlanetMessages() {
        romanticPlanets.forEach(planet => {
          if (planet.messageElement) {
            const planetPosition = new THREE.Vector3();
            planet.planet.getWorldPosition(planetPosition);
            
            // Convertir coordenadas 3D a 2D en la pantalla
            planetPosition.project(camera);
            
            const x = (planetPosition.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-planetPosition.y * 0.5 + 0.5) * window.innerHeight;
            
            // Solo mostrar si el planeta est√° frente a la c√°mara
            if (planetPosition.z < 1) {
              planet.messageElement.style.left = `${x}px`;
              planet.messageElement.style.top = `${y}px`;
              planet.messageElement.style.opacity = '0.9';
            } else {
              planet.messageElement.style.opacity = '0';
            }
          }
        });
      }

      // Actualizar part√≠culas de amor
      function updateLoveParticles(delta) {
        loveParticles.forEach(particle => {
          const screenPosition = particle.position.clone();
          screenPosition.project(camera);
          
          const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-screenPosition.y * 0.5 + 0.5) * window.innerHeight;
          
          // Movimiento flotante
          const floatOffset = Math.sin(Date.now() * 0.001 * particle.speed + particle.offset) * particle.amplitude;
          
          particle.element.style.left = `${x}px`;
          particle.element.style.top = `${y + floatOffset}px`;
          particle.element.style.opacity = '0.9';
          
          // Efecto de parpadeo
          particle.element.style.opacity = (0.7 + 0.3 * Math.sin(Date.now() * 0.002)).toString();
        });
      }

      // Actualizar mensajes flotantes
      function updateFloatingMessages(delta) {
        floatingMessages.forEach(message => {
          message.timer += delta;
          
          switch (message.state) {
            case 'waiting':
              if (message.timer > message.showTime) {
                message.state = 'showing';
                message.timer = 0;
                message.element.style.opacity = '0';
                
                // Actualizar posici√≥n
                const screenPosition = message.position.clone();
                screenPosition.project(camera);
                
                message.element.style.left = `${(screenPosition.x * 0.5 + 0.5) * window.innerWidth}px`;
                message.element.style.top = `${(-screenPosition.y * 0.5 + 0.5) * window.innerHeight}px`;
              }
              break;
              
            case 'showing':
              message.element.style.opacity = Math.min(1, message.timer / 1000).toString();
              if (message.timer > 1000) {
                message.state = 'visible';
                message.timer = 0;
              }
              break;
              
            case 'visible':
              if (message.timer > message.hideTime) {
                message.state = 'hiding';
                message.timer = 0;
              }
              break;
              
            case 'hiding':
              message.element.style.opacity = Math.max(0, 1 - message.timer / 1000).toString();
              if (message.timer > 1000) {
                message.state = 'waiting';
                message.timer = 0;
                
                // Nueva posici√≥n aleatoria
                message.position.set(
                  Math.random() * 1000 - 500,
                  Math.random() * 500 - 250,
                  Math.random() * 1000 - 500
                );
                
                // Nuevos tiempos
                message.showTime = 5000 + Math.random() * 10000;
                message.hideTime = 3000 + Math.random() * 5000;
              }
              break;
          }
        });
      }

      // Animaci√≥n
      let clock = new THREE.Clock();
      
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta() * 1000; // delta en milisegundos

        // Limitar la c√°mara para evitar temblores
        limitarCamara();

        // Rotaci√≥n del sol
        sun.rotation.y += 0.002;

        // Rotaci√≥n de planetas
        planetas.forEach(p => {
          p.pivot.rotation.y += p.speed;
          p.planet.rotation.y += 0.005;
        });
        
        // Rotaci√≥n de planetas rom√°nticos
        romanticPlanets.forEach(p => {
          p.pivot.rotation.y += p.speed;
          p.planet.rotation.y += 0.005;
        });

        // Animaci√≥n de qu√°sar
        quasar.group.rotation.y += 0.004;
        
        // Animaci√≥n de jets del qu√°sar
        quasar.leftJet.children.forEach(jet => {
          jet.position.x -= jet.userData.speed;
          if (jet.position.x < -200) {
            jet.position.x = 0;
          }
        });
        
        quasar.rightJet.children.forEach(jet => {
          jet.position.x += jet.userData.speed;
          if (jet.position.x > 200) {
            jet.position.x = 0;
          }
        });
        
        quasar.group.children.forEach(child => {
          if (child.userData && child.userData.speed) {
            const distance = child.position.length();
            const direction = child.position.clone().normalize();
            child.position.add(direction.multiplyScalar(child.userData.speed));
            
            if (child.position.length() > 70) {
              child.position.set(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
              ).normalize().multiplyScalar(25 + Math.random() * 10);
            }
          }
        });

        // Animaci√≥n de asteroides
        asteroidBelt.children.forEach(asteroid => {
          asteroid.rotation.x += asteroid.userData.rotationSpeed;
          asteroid.rotation.y += asteroid.userData.rotationSpeed * 0.7;
          asteroid.rotation.z += asteroid.userData.rotationSpeed * 0.3;
          
          const angle = Math.atan2(asteroid.position.z, asteroid.position.x);
          const newAngle = angle + asteroid.userData.orbitSpeed;
          const radius = Math.sqrt(asteroid.position.x * asteroid.position.x + asteroid.position.z * asteroid.position.z);
          
          asteroid.position.x = Math.cos(newAngle) * radius;
          asteroid.position.z = Math.sin(newAngle) * radius;
        });

        // Animaci√≥n de estrellas fugaces
        meteors.forEach(meteor => {
          // Aplicar velocidad
          meteor.position.add(meteor.userData.velocity.clone().multiplyScalar(0.4));
          
          // Aplicar curvatura a la trayectoria
          const curve = meteor.userData.curveAxis.clone().multiplyScalar(meteor.userData.curveAmount);
          meteor.userData.velocity.add(curve);
          meteor.userData.velocity.normalize();
          
          meteor.userData.life--;
          
          if (meteor.userData.life <= 0) {
            const groupCenter = new THREE.Vector3(
              Math.random() * 1500 - 750,
              Math.random() * 800 - 400,
              Math.random() * 1500 - 750
            );
            
            const spread = 100;
            meteor.position.set(
              groupCenter.x + (Math.random() - 0.5) * spread,
              groupCenter.y + (Math.random() - 0.5) * spread,
              groupCenter.z + (Math.random() - 0.5) * spread
            );
            
            // Nueva direcci√≥n
            const baseDirection = new THREE.Vector3(
              Math.random() - 0.5,
              (Math.random() - 0.8) * 0.5,
              Math.random() - 0.5
            ).normalize();
            
            const variation = 0.3;
            const direction = new THREE.Vector3(
              baseDirection.x + (Math.random() - 0.5) * variation,
              baseDirection.y + (Math.random() - 0.5) * variation,
              baseDirection.z + (Math.random() - 0.5) * variation
            ).normalize();
            
            meteor.userData.velocity = direction.multiplyScalar(25 + Math.random() * 15);
            meteor.userData.life = 150 + Math.random() * 100;
          }
          
          // Efecto de parpadeo
          meteor.material.opacity = 0.6 + 0.4 * Math.sin(Date.now() * 0.01 + meteor.userData.group);
        });

        // Animaci√≥n de nebulosas
        nebulas.forEach(nebula => {
          nebula.rotation.x += nebula.userData.rotationSpeed;
          nebula.rotation.y += nebula.userData.rotationSpeed * 1.3;
          nebula.rotation.z += nebula.userData.rotationSpeed * 0.7;
        });

        // Animaci√≥n de galaxias de fondo
        backgroundGalaxies.forEach(galaxy => {
          galaxy.rotation.z += galaxy.userData.rotationSpeed;
        });

        // Animaci√≥n de part√≠culas m√°gicas
        if (magicParticles.alphas) {
          for (let i = 0; i < magicParticles.alphas.length; i++) {
            magicParticles.alphas[i] = 0.3 + 0.7 * Math.sin(Date.now() * 0.001 + i * 0.1);
          }
          magicParticles.particles.geometry.attributes.alpha.needsUpdate = true;
        }

        // Animaci√≥n de constelaci√≥n del coraz√≥n
        if (heartConstellation.alphas) {
          for (let i = 0; i < heartConstellation.alphas.length; i++) {
            heartConstellation.alphas[i] = 0.5 + 0.5 * Math.sin(Date.now() * 0.002 + i * 0.2);
          }
          heartConstellation.stars.geometry.attributes.alpha.needsUpdate = true;
          
          // Rotar la constelaci√≥n lentamente
          heartConstellation.group.rotation.z += 0.0005;
        }

        // Actualizar indicador de distancia
        updateDistanceIndicator();
        
        // Actualizar mensajes de planetas
        updatePlanetMessages();
        
        // Actualizar part√≠culas de amor
        updateLoveParticles(delta);
        
        // Actualizar mensajes flotantes
        updateFloatingMessages(delta);

        controls.update();
        renderer.render(scene, camera);
				
				// dentro de animate()
heartConstellation.stars.material.opacity =
  0.5 + 0.5 * Math.sin(Date.now() * 0.003);

magicParticles.particles.material.opacity =
  0.3 + 0.7 * Math.sin(Date.now() * 0.002);
      }
      animate();

      // Resize handler
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Detectar si es m√≥vil y ajustar par√°metros
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      if (isMobile) {
        // Ajustes espec√≠ficos para m√≥viles
        controls.minDistance = 80;
        controls.maxDistance = 1000;
        camera.position.set(0, 150, 400);
      }
   
  </script>
</body>
</html>